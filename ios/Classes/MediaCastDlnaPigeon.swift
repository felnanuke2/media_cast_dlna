// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Represents the current transport state
enum TransportState: Int {
  case stopped = 0
  case playing = 1
  case paused = 2
  case transitioning = 3
  case noMediaPresent = 4
}

/// Represents a Unique Device Name (UDN) following object calisthenics
///
/// Generated class from Pigeon that represents data sent in messages.
struct DeviceUdn {
  var value: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DeviceUdn? {
    let value = pigeonVar_list[0] as! String

    return DeviceUdn(
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      value
    ]
  }
}

/// Volume level representation following object calisthenics
///
/// Generated class from Pigeon that represents data sent in messages.
struct VolumeLevel {
  var percentage: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VolumeLevel? {
    let percentage = pigeonVar_list[0] as! Int64

    return VolumeLevel(
      percentage: percentage
    )
  }
  func toList() -> [Any?] {
    return [
      percentage
    ]
  }
}

/// Mute state representation
///
/// Generated class from Pigeon that represents data sent in messages.
struct MuteState {
  var isMuted: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MuteState? {
    let isMuted = pigeonVar_list[0] as! Bool

    return MuteState(
      isMuted: isMuted
    )
  }
  func toList() -> [Any?] {
    return [
      isMuted
    ]
  }
}

/// Volume information combining level and mute state
///
/// Generated class from Pigeon that represents data sent in messages.
struct VolumeInfo {
  var level: VolumeLevel
  var muteState: MuteState


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VolumeInfo? {
    let level = pigeonVar_list[0] as! VolumeLevel
    let muteState = pigeonVar_list[1] as! MuteState

    return VolumeInfo(
      level: level,
      muteState: muteState
    )
  }
  func toList() -> [Any?] {
    return [
      level,
      muteState,
    ]
  }
}

/// Represents a mute operation
///
/// Generated class from Pigeon that represents data sent in messages.
struct MuteOperation {
  var shouldMute: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MuteOperation? {
    let shouldMute = pigeonVar_list[0] as! Bool

    return MuteOperation(
      shouldMute: shouldMute
    )
  }
  func toList() -> [Any?] {
    return [
      shouldMute
    ]
  }
}

/// Represents a position in time (seconds)
///
/// Generated class from Pigeon that represents data sent in messages.
struct TimePosition {
  var seconds: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TimePosition? {
    let seconds = pigeonVar_list[0] as! Int64

    return TimePosition(
      seconds: seconds
    )
  }
  func toList() -> [Any?] {
    return [
      seconds
    ]
  }
}

/// Represents a duration in time (seconds)
///
/// Generated class from Pigeon that represents data sent in messages.
struct TimeDuration {
  var seconds: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> TimeDuration? {
    let seconds = pigeonVar_list[0] as! Int64

    return TimeDuration(
      seconds: seconds
    )
  }
  func toList() -> [Any?] {
    return [
      seconds
    ]
  }
}

/// Represents a URL following object calisthenics
///
/// Generated class from Pigeon that represents data sent in messages.
struct Url {
  var value: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> Url? {
    let value = pigeonVar_list[0] as! String

    return Url(
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      value
    ]
  }
}

/// Represents an IP address following object calisthenics
///
/// Generated class from Pigeon that represents data sent in messages.
struct IpAddress {
  var value: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> IpAddress? {
    let value = pigeonVar_list[0] as! String

    return IpAddress(
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      value
    ]
  }
}

/// Represents a network port following object calisthenics
///
/// Generated class from Pigeon that represents data sent in messages.
struct NetworkPort {
  var value: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> NetworkPort? {
    let value = pigeonVar_list[0] as! Int64

    return NetworkPort(
      value: value
    )
  }
  func toList() -> [Any?] {
    return [
      value
    ]
  }
}

/// Represents a discovery timeout following object calisthenics
///
/// Generated class from Pigeon that represents data sent in messages.
struct DiscoveryTimeout {
  var seconds: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DiscoveryTimeout? {
    let seconds = pigeonVar_list[0] as! Int64

    return DiscoveryTimeout(
      seconds: seconds
    )
  }
  func toList() -> [Any?] {
    return [
      seconds
    ]
  }
}

/// Represents a search target for discovery
///
/// Generated class from Pigeon that represents data sent in messages.
struct SearchTarget {
  var target: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SearchTarget? {
    let target = pigeonVar_list[0] as! String

    return SearchTarget(
      target: target
    )
  }
  func toList() -> [Any?] {
    return [
      target
    ]
  }
}

/// Discovery options with descriptive classes
///
/// Generated class from Pigeon that represents data sent in messages.
struct DiscoveryOptions {
  var searchTarget: SearchTarget? = nil
  var timeout: DiscoveryTimeout


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DiscoveryOptions? {
    let searchTarget: SearchTarget? = nilOrValue(pigeonVar_list[0])
    let timeout = pigeonVar_list[1] as! DiscoveryTimeout

    return DiscoveryOptions(
      searchTarget: searchTarget,
      timeout: timeout
    )
  }
  func toList() -> [Any?] {
    return [
      searchTarget,
      timeout,
    ]
  }
}

/// Represents a UPnP/DLNA device discovered on the network
///
/// Generated class from Pigeon that represents data sent in messages.
struct DlnaDevice {
  var udn: DeviceUdn
  var friendlyName: String
  var deviceType: String
  var manufacturerName: String
  var modelName: String
  var ipAddress: IpAddress
  var port: NetworkPort
  var modelDescription: String? = nil
  var presentationUrl: Url? = nil
  var iconUrl: Url? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DlnaDevice? {
    let udn = pigeonVar_list[0] as! DeviceUdn
    let friendlyName = pigeonVar_list[1] as! String
    let deviceType = pigeonVar_list[2] as! String
    let manufacturerName = pigeonVar_list[3] as! String
    let modelName = pigeonVar_list[4] as! String
    let ipAddress = pigeonVar_list[5] as! IpAddress
    let port = pigeonVar_list[6] as! NetworkPort
    let modelDescription: String? = nilOrValue(pigeonVar_list[7])
    let presentationUrl: Url? = nilOrValue(pigeonVar_list[8])
    let iconUrl: Url? = nilOrValue(pigeonVar_list[9])

    return DlnaDevice(
      udn: udn,
      friendlyName: friendlyName,
      deviceType: deviceType,
      manufacturerName: manufacturerName,
      modelName: modelName,
      ipAddress: ipAddress,
      port: port,
      modelDescription: modelDescription,
      presentationUrl: presentationUrl,
      iconUrl: iconUrl
    )
  }
  func toList() -> [Any?] {
    return [
      udn,
      friendlyName,
      deviceType,
      manufacturerName,
      modelName,
      ipAddress,
      port,
      modelDescription,
      presentationUrl,
      iconUrl,
    ]
  }
}

/// Represents a UPnP service available on a device
///
/// Generated class from Pigeon that represents data sent in messages.
struct DlnaService {
  var serviceType: String
  var serviceId: String
  var scpdUrl: Url
  var controlUrl: Url
  var eventSubUrl: Url


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DlnaService? {
    let serviceType = pigeonVar_list[0] as! String
    let serviceId = pigeonVar_list[1] as! String
    let scpdUrl = pigeonVar_list[2] as! Url
    let controlUrl = pigeonVar_list[3] as! Url
    let eventSubUrl = pigeonVar_list[4] as! Url

    return DlnaService(
      serviceType: serviceType,
      serviceId: serviceId,
      scpdUrl: scpdUrl,
      controlUrl: controlUrl,
      eventSubUrl: eventSubUrl
    )
  }
  func toList() -> [Any?] {
    return [
      serviceType,
      serviceId,
      scpdUrl,
      controlUrl,
      eventSubUrl,
    ]
  }
}

/// Represents a subtitle track
///
/// Generated class from Pigeon that represents data sent in messages.
struct SubtitleTrack {
  var id: String
  var uri: Url
  var mimeType: String
  var language: String
  var title: String? = nil
  var isDefault: Bool? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> SubtitleTrack? {
    let id = pigeonVar_list[0] as! String
    let uri = pigeonVar_list[1] as! Url
    let mimeType = pigeonVar_list[2] as! String
    let language = pigeonVar_list[3] as! String
    let title: String? = nilOrValue(pigeonVar_list[4])
    let isDefault: Bool? = nilOrValue(pigeonVar_list[5])

    return SubtitleTrack(
      id: id,
      uri: uri,
      mimeType: mimeType,
      language: language,
      title: title,
      isDefault: isDefault
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      uri,
      mimeType,
      language,
      title,
      isDefault,
    ]
  }
}

/// Abstract class for media metadata
///
/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol MediaMetadata {

}

/// Audio-specific metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct AudioMetadata: MediaMetadata {
  var artist: String? = nil
  var album: String? = nil
  var genre: String? = nil
  var duration: TimeDuration? = nil
  var albumArtUri: Url? = nil
  var description: String? = nil
  var originalTrackNumber: Int64? = nil
  var upnpClass: String? = nil
  var title: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AudioMetadata? {
    let artist: String? = nilOrValue(pigeonVar_list[0])
    let album: String? = nilOrValue(pigeonVar_list[1])
    let genre: String? = nilOrValue(pigeonVar_list[2])
    let duration: TimeDuration? = nilOrValue(pigeonVar_list[3])
    let albumArtUri: Url? = nilOrValue(pigeonVar_list[4])
    let description: String? = nilOrValue(pigeonVar_list[5])
    let originalTrackNumber: Int64? = nilOrValue(pigeonVar_list[6])
    let upnpClass: String? = nilOrValue(pigeonVar_list[7])
    let title: String? = nilOrValue(pigeonVar_list[8])

    return AudioMetadata(
      artist: artist,
      album: album,
      genre: genre,
      duration: duration,
      albumArtUri: albumArtUri,
      description: description,
      originalTrackNumber: originalTrackNumber,
      upnpClass: upnpClass,
      title: title
    )
  }
  func toList() -> [Any?] {
    return [
      artist,
      album,
      genre,
      duration,
      albumArtUri,
      description,
      originalTrackNumber,
      upnpClass,
      title,
    ]
  }
}

/// Video-specific metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct VideoMetadata: MediaMetadata {
  var resolution: String? = nil
  var duration: TimeDuration? = nil
  var description: String? = nil
  var thumbnailUri: Url? = nil
  var genre: String? = nil
  var upnpClass: String? = nil
  var bitrate: Int64? = nil
  var title: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoMetadata? {
    let resolution: String? = nilOrValue(pigeonVar_list[0])
    let duration: TimeDuration? = nilOrValue(pigeonVar_list[1])
    let description: String? = nilOrValue(pigeonVar_list[2])
    let thumbnailUri: Url? = nilOrValue(pigeonVar_list[3])
    let genre: String? = nilOrValue(pigeonVar_list[4])
    let upnpClass: String? = nilOrValue(pigeonVar_list[5])
    let bitrate: Int64? = nilOrValue(pigeonVar_list[6])
    let title: String? = nilOrValue(pigeonVar_list[7])

    return VideoMetadata(
      resolution: resolution,
      duration: duration,
      description: description,
      thumbnailUri: thumbnailUri,
      genre: genre,
      upnpClass: upnpClass,
      bitrate: bitrate,
      title: title
    )
  }
  func toList() -> [Any?] {
    return [
      resolution,
      duration,
      description,
      thumbnailUri,
      genre,
      upnpClass,
      bitrate,
      title,
    ]
  }
}

/// Image-specific metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct ImageMetadata: MediaMetadata {
  var resolution: String? = nil
  var description: String? = nil
  var thumbnailUri: Url? = nil
  var date: String? = nil
  var upnpClass: String? = nil
  var title: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ImageMetadata? {
    let resolution: String? = nilOrValue(pigeonVar_list[0])
    let description: String? = nilOrValue(pigeonVar_list[1])
    let thumbnailUri: Url? = nilOrValue(pigeonVar_list[2])
    let date: String? = nilOrValue(pigeonVar_list[3])
    let upnpClass: String? = nilOrValue(pigeonVar_list[4])
    let title: String? = nilOrValue(pigeonVar_list[5])

    return ImageMetadata(
      resolution: resolution,
      description: description,
      thumbnailUri: thumbnailUri,
      date: date,
      upnpClass: upnpClass,
      title: title
    )
  }
  func toList() -> [Any?] {
    return [
      resolution,
      description,
      thumbnailUri,
      date,
      upnpClass,
      title,
    ]
  }
}

/// Represents media content that can be played
///
/// Generated class from Pigeon that represents data sent in messages.
struct MediaItem {
  var id: String
  var title: String
  var uri: Url
  var mimeType: String
  var metadata: MediaMetadata? = nil
  var size: Int64? = nil
  var subtitleTracks: [SubtitleTrack]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MediaItem? {
    let id = pigeonVar_list[0] as! String
    let title = pigeonVar_list[1] as! String
    let uri = pigeonVar_list[2] as! Url
    let mimeType = pigeonVar_list[3] as! String
    let metadata: MediaMetadata? = nilOrValue(pigeonVar_list[4])
    let size: Int64? = nilOrValue(pigeonVar_list[5])
    let subtitleTracks: [SubtitleTrack]? = nilOrValue(pigeonVar_list[6])

    return MediaItem(
      id: id,
      title: title,
      uri: uri,
      mimeType: mimeType,
      metadata: metadata,
      size: size,
      subtitleTracks: subtitleTracks
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      uri,
      mimeType,
      metadata,
      size,
      subtitleTracks,
    ]
  }
}

/// Represents playback information with descriptive time classes
///
/// Generated class from Pigeon that represents data sent in messages.
struct PlaybackInfo {
  var state: TransportState
  var position: TimePosition
  var duration: TimeDuration
  var currentTrackUri: String? = nil
  var currentTrackMetadata: MediaMetadata? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlaybackInfo? {
    let state = pigeonVar_list[0] as! TransportState
    let position = pigeonVar_list[1] as! TimePosition
    let duration = pigeonVar_list[2] as! TimeDuration
    let currentTrackUri: String? = nilOrValue(pigeonVar_list[3])
    let currentTrackMetadata: MediaMetadata? = nilOrValue(pigeonVar_list[4])

    return PlaybackInfo(
      state: state,
      position: position,
      duration: duration,
      currentTrackUri: currentTrackUri,
      currentTrackMetadata: currentTrackMetadata
    )
  }
  func toList() -> [Any?] {
    return [
      state,
      position,
      duration,
      currentTrackUri,
      currentTrackMetadata,
    ]
  }
}

private class MediaCastDlnaPigeonPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TransportState(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      return DeviceUdn.fromList(self.readValue() as! [Any?])
    case 131:
      return VolumeLevel.fromList(self.readValue() as! [Any?])
    case 132:
      return MuteState.fromList(self.readValue() as! [Any?])
    case 133:
      return VolumeInfo.fromList(self.readValue() as! [Any?])
    case 134:
      return MuteOperation.fromList(self.readValue() as! [Any?])
    case 135:
      return TimePosition.fromList(self.readValue() as! [Any?])
    case 136:
      return TimeDuration.fromList(self.readValue() as! [Any?])
    case 137:
      return Url.fromList(self.readValue() as! [Any?])
    case 138:
      return IpAddress.fromList(self.readValue() as! [Any?])
    case 139:
      return NetworkPort.fromList(self.readValue() as! [Any?])
    case 140:
      return DiscoveryTimeout.fromList(self.readValue() as! [Any?])
    case 141:
      return SearchTarget.fromList(self.readValue() as! [Any?])
    case 142:
      return DiscoveryOptions.fromList(self.readValue() as! [Any?])
    case 143:
      return DlnaDevice.fromList(self.readValue() as! [Any?])
    case 144:
      return DlnaService.fromList(self.readValue() as! [Any?])
    case 145:
      return SubtitleTrack.fromList(self.readValue() as! [Any?])
    case 146:
      return AudioMetadata.fromList(self.readValue() as! [Any?])
    case 147:
      return VideoMetadata.fromList(self.readValue() as! [Any?])
    case 148:
      return ImageMetadata.fromList(self.readValue() as! [Any?])
    case 149:
      return MediaItem.fromList(self.readValue() as! [Any?])
    case 150:
      return PlaybackInfo.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MediaCastDlnaPigeonPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? TransportState {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? DeviceUdn {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? VolumeLevel {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? MuteState {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? VolumeInfo {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? MuteOperation {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? TimePosition {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? TimeDuration {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? Url {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? IpAddress {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? NetworkPort {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? DiscoveryTimeout {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? SearchTarget {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? DiscoveryOptions {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? DlnaDevice {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? DlnaService {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? SubtitleTrack {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? AudioMetadata {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? VideoMetadata {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? ImageMetadata {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? MediaItem {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else if let value = value as? PlaybackInfo {
      super.writeByte(150)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MediaCastDlnaPigeonPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MediaCastDlnaPigeonPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MediaCastDlnaPigeonPigeonCodecWriter(data: data)
  }
}

class MediaCastDlnaPigeonPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MediaCastDlnaPigeonPigeonCodec(readerWriter: MediaCastDlnaPigeonPigeonCodecReaderWriter())
}


/// Host API for device discovery and control
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol MediaCastDlnaApi {
  func initializeUpnpService(completion: @escaping (Result<Void, Error>) -> Void)
  func isUpnpServiceInitialized(completion: @escaping (Result<Bool, Error>) -> Void)
  func shutdownUpnpService(completion: @escaping (Result<Void, Error>) -> Void)
  func startDiscovery(options: DiscoveryOptions, completion: @escaping (Result<Void, Error>) -> Void)
  func stopDiscovery(completion: @escaping (Result<Void, Error>) -> Void)
  func getDiscoveredDevices(completion: @escaping (Result<[DlnaDevice], Error>) -> Void)
  func refreshDevice(deviceUdn: DeviceUdn, completion: @escaping (Result<DlnaDevice?, Error>) -> Void)
  func getDeviceServices(deviceUdn: DeviceUdn, completion: @escaping (Result<[DlnaService], Error>) -> Void)
  func hasService(deviceUdn: DeviceUdn, serviceType: String, completion: @escaping (Result<Bool, Error>) -> Void)
  func isDeviceOnline(deviceUdn: DeviceUdn, completion: @escaping (Result<Bool, Error>) -> Void)
  func setMediaUri(deviceUdn: DeviceUdn, uri: Url, metadata: MediaMetadata, completion: @escaping (Result<Void, Error>) -> Void)
  func setMediaUriWithSubtitles(deviceUdn: DeviceUdn, uri: Url, metadata: MediaMetadata, subtitleTracks: [SubtitleTrack], completion: @escaping (Result<Void, Error>) -> Void)
  func supportsSubtitleControl(deviceUdn: DeviceUdn, completion: @escaping (Result<Bool, Error>) -> Void)
  func setSubtitleTrack(deviceUdn: DeviceUdn, subtitleTrackId: String?, completion: @escaping (Result<Void, Error>) -> Void)
  func getAvailableSubtitleTracks(deviceUdn: DeviceUdn, completion: @escaping (Result<[SubtitleTrack], Error>) -> Void)
  func getCurrentSubtitleTrack(deviceUdn: DeviceUdn, completion: @escaping (Result<SubtitleTrack?, Error>) -> Void)
  func play(deviceUdn: DeviceUdn, completion: @escaping (Result<Void, Error>) -> Void)
  func pause(deviceUdn: DeviceUdn, completion: @escaping (Result<Void, Error>) -> Void)
  func stop(deviceUdn: DeviceUdn, completion: @escaping (Result<Void, Error>) -> Void)
  func seek(deviceUdn: DeviceUdn, position: TimePosition, completion: @escaping (Result<Void, Error>) -> Void)
  func setVolume(deviceUdn: DeviceUdn, volumeLevel: VolumeLevel, completion: @escaping (Result<Void, Error>) -> Void)
  func getVolumeInfo(deviceUdn: DeviceUdn, completion: @escaping (Result<VolumeInfo, Error>) -> Void)
  func setMute(deviceUdn: DeviceUdn, muteOperation: MuteOperation, completion: @escaping (Result<Void, Error>) -> Void)
  func getPlaybackInfo(deviceUdn: DeviceUdn, completion: @escaping (Result<PlaybackInfo, Error>) -> Void)
  func getCurrentPosition(deviceUdn: DeviceUdn, completion: @escaping (Result<TimePosition, Error>) -> Void)
  func getTransportState(deviceUdn: DeviceUdn, completion: @escaping (Result<TransportState, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class MediaCastDlnaApiSetup {
  static var codec: FlutterStandardMessageCodec { MediaCastDlnaPigeonPigeonCodec.shared }
  /// Sets up an instance of `MediaCastDlnaApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: MediaCastDlnaApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let initializeUpnpServiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.initializeUpnpService\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeUpnpServiceChannel.setMessageHandler { _, reply in
        api.initializeUpnpService { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      initializeUpnpServiceChannel.setMessageHandler(nil)
    }
    let isUpnpServiceInitializedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.isUpnpServiceInitialized\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isUpnpServiceInitializedChannel.setMessageHandler { _, reply in
        api.isUpnpServiceInitialized { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isUpnpServiceInitializedChannel.setMessageHandler(nil)
    }
    let shutdownUpnpServiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.shutdownUpnpService\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      shutdownUpnpServiceChannel.setMessageHandler { _, reply in
        api.shutdownUpnpService { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      shutdownUpnpServiceChannel.setMessageHandler(nil)
    }
    let startDiscoveryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.startDiscovery\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startDiscoveryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! DiscoveryOptions
        api.startDiscovery(options: optionsArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startDiscoveryChannel.setMessageHandler(nil)
    }
    let stopDiscoveryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.stopDiscovery\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopDiscoveryChannel.setMessageHandler { _, reply in
        api.stopDiscovery { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopDiscoveryChannel.setMessageHandler(nil)
    }
    let getDiscoveredDevicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getDiscoveredDevices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDiscoveredDevicesChannel.setMessageHandler { _, reply in
        api.getDiscoveredDevices { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDiscoveredDevicesChannel.setMessageHandler(nil)
    }
    let refreshDeviceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.refreshDevice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      refreshDeviceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.refreshDevice(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      refreshDeviceChannel.setMessageHandler(nil)
    }
    let getDeviceServicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getDeviceServices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDeviceServicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.getDeviceServices(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDeviceServicesChannel.setMessageHandler(nil)
    }
    let hasServiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.hasService\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasServiceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        let serviceTypeArg = args[1] as! String
        api.hasService(deviceUdn: deviceUdnArg, serviceType: serviceTypeArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      hasServiceChannel.setMessageHandler(nil)
    }
    let isDeviceOnlineChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.isDeviceOnline\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isDeviceOnlineChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.isDeviceOnline(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      isDeviceOnlineChannel.setMessageHandler(nil)
    }
    let setMediaUriChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setMediaUri\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMediaUriChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        let uriArg = args[1] as! Url
        let metadataArg = args[2] as! MediaMetadata
        api.setMediaUri(deviceUdn: deviceUdnArg, uri: uriArg, metadata: metadataArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMediaUriChannel.setMessageHandler(nil)
    }
    let setMediaUriWithSubtitlesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setMediaUriWithSubtitles\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMediaUriWithSubtitlesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        let uriArg = args[1] as! Url
        let metadataArg = args[2] as! MediaMetadata
        let subtitleTracksArg = args[3] as! [SubtitleTrack]
        api.setMediaUriWithSubtitles(deviceUdn: deviceUdnArg, uri: uriArg, metadata: metadataArg, subtitleTracks: subtitleTracksArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMediaUriWithSubtitlesChannel.setMessageHandler(nil)
    }
    let supportsSubtitleControlChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.supportsSubtitleControl\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      supportsSubtitleControlChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.supportsSubtitleControl(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      supportsSubtitleControlChannel.setMessageHandler(nil)
    }
    let setSubtitleTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setSubtitleTrack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setSubtitleTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        let subtitleTrackIdArg: String? = nilOrValue(args[1])
        api.setSubtitleTrack(deviceUdn: deviceUdnArg, subtitleTrackId: subtitleTrackIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setSubtitleTrackChannel.setMessageHandler(nil)
    }
    let getAvailableSubtitleTracksChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getAvailableSubtitleTracks\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAvailableSubtitleTracksChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.getAvailableSubtitleTracks(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAvailableSubtitleTracksChannel.setMessageHandler(nil)
    }
    let getCurrentSubtitleTrackChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getCurrentSubtitleTrack\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentSubtitleTrackChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.getCurrentSubtitleTrack(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCurrentSubtitleTrackChannel.setMessageHandler(nil)
    }
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.play\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.play(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.pause\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.pause(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.stop\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.stop(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    let seekChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.seek\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        let positionArg = args[1] as! TimePosition
        api.seek(deviceUdn: deviceUdnArg, position: positionArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      seekChannel.setMessageHandler(nil)
    }
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        let volumeLevelArg = args[1] as! VolumeLevel
        api.setVolume(deviceUdn: deviceUdnArg, volumeLevel: volumeLevelArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    let getVolumeInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getVolumeInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVolumeInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.getVolumeInfo(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getVolumeInfoChannel.setMessageHandler(nil)
    }
    let setMuteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setMute\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMuteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        let muteOperationArg = args[1] as! MuteOperation
        api.setMute(deviceUdn: deviceUdnArg, muteOperation: muteOperationArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      setMuteChannel.setMessageHandler(nil)
    }
    let getPlaybackInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getPlaybackInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlaybackInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.getPlaybackInfo(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getPlaybackInfoChannel.setMessageHandler(nil)
    }
    let getCurrentPositionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getCurrentPosition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentPositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.getCurrentPosition(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCurrentPositionChannel.setMessageHandler(nil)
    }
    let getTransportStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getTransportState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTransportStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! DeviceUdn
        api.getTransportState(deviceUdn: deviceUdnArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getTransportStateChannel.setMessageHandler(nil)
    }
  }
}
