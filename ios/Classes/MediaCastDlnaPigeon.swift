// Autogenerated from Pigeon (v22.7.4), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Any?

  init(code: String, message: String?, details: Any?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
      }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

/// Represents the current transport state
enum TransportState: Int {
  case stopped = 0
  case playing = 1
  case paused = 2
  case transitioning = 3
  case noMediaPresent = 4
}

/// Represents a UPnP/DLNA device discovered on the network
///
/// Generated class from Pigeon that represents data sent in messages.
struct DlnaDevice {
  /// Unique Device Name
  var udn: String
  /// Human-readable device name
  var friendlyName: String
  /// Device type (e.g., MediaRenderer, MediaServer)
  var deviceType: String
  /// Manufacturer name
  var manufacturerName: String
  /// Model name
  var modelName: String
  /// Device IP address
  var ipAddress: String
  /// Device port
  var port: Int64
  /// Optional model description
  var modelDescription: String? = nil
  /// Optional presentation URL
  var presentationUrl: String? = nil
  /// Optional icon URL
  var iconUrl: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DlnaDevice? {
    let udn = pigeonVar_list[0] as! String
    let friendlyName = pigeonVar_list[1] as! String
    let deviceType = pigeonVar_list[2] as! String
    let manufacturerName = pigeonVar_list[3] as! String
    let modelName = pigeonVar_list[4] as! String
    let ipAddress = pigeonVar_list[5] as! String
    let port = pigeonVar_list[6] as! Int64
    let modelDescription: String? = nilOrValue(pigeonVar_list[7])
    let presentationUrl: String? = nilOrValue(pigeonVar_list[8])
    let iconUrl: String? = nilOrValue(pigeonVar_list[9])

    return DlnaDevice(
      udn: udn,
      friendlyName: friendlyName,
      deviceType: deviceType,
      manufacturerName: manufacturerName,
      modelName: modelName,
      ipAddress: ipAddress,
      port: port,
      modelDescription: modelDescription,
      presentationUrl: presentationUrl,
      iconUrl: iconUrl
    )
  }
  func toList() -> [Any?] {
    return [
      udn,
      friendlyName,
      deviceType,
      manufacturerName,
      modelName,
      ipAddress,
      port,
      modelDescription,
      presentationUrl,
      iconUrl,
    ]
  }
}

/// Represents a UPnP service available on a device
///
/// Generated class from Pigeon that represents data sent in messages.
struct DlnaService {
  /// Service type (e.g., AVTransport, RenderingControl, ContentDirectory)
  var serviceType: String
  /// Service ID
  var serviceId: String
  /// Service Control Protocol Description URL
  var scpdUrl: String
  /// Control URL for actions
  var controlUrl: String
  /// Event subscription URL
  var eventSubUrl: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DlnaService? {
    let serviceType = pigeonVar_list[0] as! String
    let serviceId = pigeonVar_list[1] as! String
    let scpdUrl = pigeonVar_list[2] as! String
    let controlUrl = pigeonVar_list[3] as! String
    let eventSubUrl = pigeonVar_list[4] as! String

    return DlnaService(
      serviceType: serviceType,
      serviceId: serviceId,
      scpdUrl: scpdUrl,
      controlUrl: controlUrl,
      eventSubUrl: eventSubUrl
    )
  }
  func toList() -> [Any?] {
    return [
      serviceType,
      serviceId,
      scpdUrl,
      controlUrl,
      eventSubUrl,
    ]
  }
}

/// Represents media content that can be played
///
/// Generated class from Pigeon that represents data sent in messages.
struct MediaItem {
  /// Content ID
  var id: String
  /// Content title
  var title: String
  /// Content URI
  var uri: String
  /// MIME type
  var mimeType: String
  /// Structured metadata (audio, video, image)
  var metadata: MediaMetadata? = nil
  /// File size in bytes
  var size: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> MediaItem? {
    let id = pigeonVar_list[0] as! String
    let title = pigeonVar_list[1] as! String
    let uri = pigeonVar_list[2] as! String
    let mimeType = pigeonVar_list[3] as! String
    let metadata: MediaMetadata? = nilOrValue(pigeonVar_list[4])
    let size: Int64? = nilOrValue(pigeonVar_list[5])

    return MediaItem(
      id: id,
      title: title,
      uri: uri,
      mimeType: mimeType,
      metadata: metadata,
      size: size
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      title,
      uri,
      mimeType,
      metadata,
      size,
    ]
  }
}

/// Abstract class for media metadata
///
/// Generated class from Pigeon that represents data sent in messages.
/// This protocol should not be extended by any user class outside of the generated file.
protocol MediaMetadata {

}

/// Audio-specific metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct AudioMetadata: MediaMetadata {
  var artist: String? = nil
  var album: String? = nil
  var genre: String? = nil
  var duration: Int64? = nil
  var albumArtUri: String? = nil
  var description: String? = nil
  var originalTrackNumber: Int64? = nil
  var upnpClass: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AudioMetadata? {
    let artist: String? = nilOrValue(pigeonVar_list[0])
    let album: String? = nilOrValue(pigeonVar_list[1])
    let genre: String? = nilOrValue(pigeonVar_list[2])
    let duration: Int64? = nilOrValue(pigeonVar_list[3])
    let albumArtUri: String? = nilOrValue(pigeonVar_list[4])
    let description: String? = nilOrValue(pigeonVar_list[5])
    let originalTrackNumber: Int64? = nilOrValue(pigeonVar_list[6])
    let upnpClass: String? = nilOrValue(pigeonVar_list[7])

    return AudioMetadata(
      artist: artist,
      album: album,
      genre: genre,
      duration: duration,
      albumArtUri: albumArtUri,
      description: description,
      originalTrackNumber: originalTrackNumber,
      upnpClass: upnpClass
    )
  }
  func toList() -> [Any?] {
    return [
      artist,
      album,
      genre,
      duration,
      albumArtUri,
      description,
      originalTrackNumber,
      upnpClass,
    ]
  }
}

/// Video-specific metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct VideoMetadata: MediaMetadata {
  var resolution: String? = nil
  var duration: Int64? = nil
  var description: String? = nil
  var thumbnailUri: String? = nil
  var genre: String? = nil
  var upnpClass: String? = nil
  var bitrate: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VideoMetadata? {
    let resolution: String? = nilOrValue(pigeonVar_list[0])
    let duration: Int64? = nilOrValue(pigeonVar_list[1])
    let description: String? = nilOrValue(pigeonVar_list[2])
    let thumbnailUri: String? = nilOrValue(pigeonVar_list[3])
    let genre: String? = nilOrValue(pigeonVar_list[4])
    let upnpClass: String? = nilOrValue(pigeonVar_list[5])
    let bitrate: Int64? = nilOrValue(pigeonVar_list[6])

    return VideoMetadata(
      resolution: resolution,
      duration: duration,
      description: description,
      thumbnailUri: thumbnailUri,
      genre: genre,
      upnpClass: upnpClass,
      bitrate: bitrate
    )
  }
  func toList() -> [Any?] {
    return [
      resolution,
      duration,
      description,
      thumbnailUri,
      genre,
      upnpClass,
      bitrate,
    ]
  }
}

/// Image-specific metadata
///
/// Generated class from Pigeon that represents data sent in messages.
struct ImageMetadata: MediaMetadata {
  var resolution: String? = nil
  var description: String? = nil
  var thumbnailUri: String? = nil
  var date: String? = nil
  var upnpClass: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> ImageMetadata? {
    let resolution: String? = nilOrValue(pigeonVar_list[0])
    let description: String? = nilOrValue(pigeonVar_list[1])
    let thumbnailUri: String? = nilOrValue(pigeonVar_list[2])
    let date: String? = nilOrValue(pigeonVar_list[3])
    let upnpClass: String? = nilOrValue(pigeonVar_list[4])

    return ImageMetadata(
      resolution: resolution,
      description: description,
      thumbnailUri: thumbnailUri,
      date: date,
      upnpClass: upnpClass
    )
  }
  func toList() -> [Any?] {
    return [
      resolution,
      description,
      thumbnailUri,
      date,
      upnpClass,
    ]
  }
}

/// Represents playback information
///
/// Generated class from Pigeon that represents data sent in messages.
struct PlaybackInfo {
  /// Current transport state
  var state: TransportState
  /// Current position in seconds
  var position: Int64
  /// Total duration in seconds
  var duration: Int64
  /// Current track URI
  var currentTrackUri: String? = nil
  /// Current track metadata
  var currentTrackMetadata: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PlaybackInfo? {
    let state = pigeonVar_list[0] as! TransportState
    let position = pigeonVar_list[1] as! Int64
    let duration = pigeonVar_list[2] as! Int64
    let currentTrackUri: String? = nilOrValue(pigeonVar_list[3])
    let currentTrackMetadata: String? = nilOrValue(pigeonVar_list[4])

    return PlaybackInfo(
      state: state,
      position: position,
      duration: duration,
      currentTrackUri: currentTrackUri,
      currentTrackMetadata: currentTrackMetadata
    )
  }
  func toList() -> [Any?] {
    return [
      state,
      position,
      duration,
      currentTrackUri,
      currentTrackMetadata,
    ]
  }
}

/// Volume information
///
/// Generated class from Pigeon that represents data sent in messages.
struct VolumeInfo {
  /// Volume level (0-100)
  var volume: Int64
  /// Whether audio is muted
  var muted: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> VolumeInfo? {
    let volume = pigeonVar_list[0] as! Int64
    let muted = pigeonVar_list[1] as! Bool

    return VolumeInfo(
      volume: volume,
      muted: muted
    )
  }
  func toList() -> [Any?] {
    return [
      volume,
      muted,
    ]
  }
}

/// Discovery options
///
/// Generated class from Pigeon that represents data sent in messages.
struct DiscoveryOptions {
  /// Search target (ST header) - can be "upnp:rootdevice", "ssdp:all", or specific device type
  var searchTarget: String? = nil
  /// Discovery timeout in seconds
  var timeout: Int64


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> DiscoveryOptions? {
    let searchTarget: String? = nilOrValue(pigeonVar_list[0])
    let timeout = pigeonVar_list[1] as! Int64

    return DiscoveryOptions(
      searchTarget: searchTarget,
      timeout: timeout
    )
  }
  func toList() -> [Any?] {
    return [
      searchTarget,
      timeout,
    ]
  }
}

private class MediaCastDlnaPigeonPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return TransportState(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      return DlnaDevice.fromList(self.readValue() as! [Any?])
    case 131:
      return DlnaService.fromList(self.readValue() as! [Any?])
    case 132:
      return MediaItem.fromList(self.readValue() as! [Any?])
    case 133:
      return AudioMetadata.fromList(self.readValue() as! [Any?])
    case 134:
      return VideoMetadata.fromList(self.readValue() as! [Any?])
    case 135:
      return ImageMetadata.fromList(self.readValue() as! [Any?])
    case 136:
      return PlaybackInfo.fromList(self.readValue() as! [Any?])
    case 137:
      return VolumeInfo.fromList(self.readValue() as! [Any?])
    case 138:
      return DiscoveryOptions.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MediaCastDlnaPigeonPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? TransportState {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? DlnaDevice {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? DlnaService {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? MediaItem {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? AudioMetadata {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? VideoMetadata {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? ImageMetadata {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? PlaybackInfo {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? VolumeInfo {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? DiscoveryOptions {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MediaCastDlnaPigeonPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MediaCastDlnaPigeonPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MediaCastDlnaPigeonPigeonCodecWriter(data: data)
  }
}

class MediaCastDlnaPigeonPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MediaCastDlnaPigeonPigeonCodec(readerWriter: MediaCastDlnaPigeonPigeonCodecReaderWriter())
}

/// Host API for device discovery and control
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol MediaCastDlnaApi {
  /// Initialize the UPnP service and prepare for device discovery/control
  /// This must be called before any other operations
  func initializeUpnpService() throws
  /// Check if UPnP service is initialized and ready
  func isUpnpServiceInitialized() throws -> Bool
  /// Shutdown and cleanup UPnP service
  func shutdownUpnpService() throws
  /// Start UPnP/DLNA device discovery
  /// Returns immediately, devices are reported via the DeviceDiscoveryApi callback
  /// Note: initializeUpnpService() must be called first
  func startDiscovery(options: DiscoveryOptions) throws
  /// Stop device discovery
  func stopDiscovery() throws
  /// Get list of currently discovered devices
  func getDiscoveredDevices() throws -> [DlnaDevice]
  /// Refresh device information
  func refreshDevice(deviceUdn: String) throws -> DlnaDevice?
  /// Get services available on a device
  func getDeviceServices(deviceUdn: String) throws -> [DlnaService]
  /// Check if device supports a specific service type
  func hasService(deviceUdn: String, serviceType: String) throws -> Bool
  /// Browse content directory of a media server
  /// parentId: ID of the container to browse (use "0" for root)
  /// startIndex: Starting index for pagination
  /// requestCount: Number of items to request
  func browseContentDirectory(deviceUdn: String, parentId: String, startIndex: Int64, requestCount: Int64) throws -> [MediaItem]
  /// Search content directory
  func searchContentDirectory(deviceUdn: String, containerId: String, searchCriteria: String, startIndex: Int64, requestCount: Int64) throws -> [MediaItem]
  /// Set the media URI to play on a renderer
  func setMediaUri(deviceUdn: String, uri: String, metadata: MediaMetadata) throws
  /// Start playback
  func play(deviceUdn: String) throws
  /// Pause playback
  func pause(deviceUdn: String) throws
  /// Stop playback
  func stop(deviceUdn: String) throws
  /// Seek to specific position (in seconds)
  func seek(deviceUdn: String, positionSeconds: Int64) throws
  /// Skip to next track
  func next(deviceUdn: String) throws
  /// Skip to previous track
  func previous(deviceUdn: String) throws
  /// Set volume (0-100)
  func setVolume(deviceUdn: String, volume: Int64) throws
  /// Get current volume info
  func getVolumeInfo(deviceUdn: String) throws -> VolumeInfo
  /// Mute/unmute audio
  func setMute(deviceUdn: String, muted: Bool) throws
  /// Get current playback information
  func getPlaybackInfo(deviceUdn: String) throws -> PlaybackInfo
  /// Get current position info
  func getCurrentPosition(deviceUdn: String) throws -> Int64
  /// Get transport state
  func getTransportState(deviceUdn: String) throws -> TransportState
  /// Get platform version
  func getPlatformVersion() throws -> String
  /// Check if UPnP is available on the platform
  func isUpnpAvailable() throws -> Bool
  /// Get network interface information
  func getNetworkInterfaces() throws -> [String]
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class MediaCastDlnaApiSetup {
  static var codec: FlutterStandardMessageCodec { MediaCastDlnaPigeonPigeonCodec.shared }
  /// Sets up an instance of `MediaCastDlnaApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: MediaCastDlnaApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Initialize the UPnP service and prepare for device discovery/control
    /// This must be called before any other operations
    let initializeUpnpServiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.initializeUpnpService\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeUpnpServiceChannel.setMessageHandler { _, reply in
        do {
          try api.initializeUpnpService()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      initializeUpnpServiceChannel.setMessageHandler(nil)
    }
    /// Check if UPnP service is initialized and ready
    let isUpnpServiceInitializedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.isUpnpServiceInitialized\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isUpnpServiceInitializedChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isUpnpServiceInitialized()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isUpnpServiceInitializedChannel.setMessageHandler(nil)
    }
    /// Shutdown and cleanup UPnP service
    let shutdownUpnpServiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.shutdownUpnpService\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      shutdownUpnpServiceChannel.setMessageHandler { _, reply in
        do {
          try api.shutdownUpnpService()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      shutdownUpnpServiceChannel.setMessageHandler(nil)
    }
    /// Start UPnP/DLNA device discovery
    /// Returns immediately, devices are reported via the DeviceDiscoveryApi callback
    /// Note: initializeUpnpService() must be called first
    let startDiscoveryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.startDiscovery\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startDiscoveryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! DiscoveryOptions
        do {
          try api.startDiscovery(options: optionsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      startDiscoveryChannel.setMessageHandler(nil)
    }
    /// Stop device discovery
    let stopDiscoveryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.stopDiscovery\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopDiscoveryChannel.setMessageHandler { _, reply in
        do {
          try api.stopDiscovery()
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopDiscoveryChannel.setMessageHandler(nil)
    }
    /// Get list of currently discovered devices
    let getDiscoveredDevicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getDiscoveredDevices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDiscoveredDevicesChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getDiscoveredDevices()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDiscoveredDevicesChannel.setMessageHandler(nil)
    }
    /// Refresh device information
    let refreshDeviceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.refreshDevice\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      refreshDeviceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          let result = try api.refreshDevice(deviceUdn: deviceUdnArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      refreshDeviceChannel.setMessageHandler(nil)
    }
    /// Get services available on a device
    let getDeviceServicesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getDeviceServices\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDeviceServicesChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          let result = try api.getDeviceServices(deviceUdn: deviceUdnArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getDeviceServicesChannel.setMessageHandler(nil)
    }
    /// Check if device supports a specific service type
    let hasServiceChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.hasService\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasServiceChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        let serviceTypeArg = args[1] as! String
        do {
          let result = try api.hasService(deviceUdn: deviceUdnArg, serviceType: serviceTypeArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      hasServiceChannel.setMessageHandler(nil)
    }
    /// Browse content directory of a media server
    /// parentId: ID of the container to browse (use "0" for root)
    /// startIndex: Starting index for pagination
    /// requestCount: Number of items to request
    let browseContentDirectoryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.browseContentDirectory\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      browseContentDirectoryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        let parentIdArg = args[1] as! String
        let startIndexArg = args[2] as! Int64
        let requestCountArg = args[3] as! Int64
        do {
          let result = try api.browseContentDirectory(deviceUdn: deviceUdnArg, parentId: parentIdArg, startIndex: startIndexArg, requestCount: requestCountArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      browseContentDirectoryChannel.setMessageHandler(nil)
    }
    /// Search content directory
    let searchContentDirectoryChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.searchContentDirectory\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      searchContentDirectoryChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        let containerIdArg = args[1] as! String
        let searchCriteriaArg = args[2] as! String
        let startIndexArg = args[3] as! Int64
        let requestCountArg = args[4] as! Int64
        do {
          let result = try api.searchContentDirectory(deviceUdn: deviceUdnArg, containerId: containerIdArg, searchCriteria: searchCriteriaArg, startIndex: startIndexArg, requestCount: requestCountArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      searchContentDirectoryChannel.setMessageHandler(nil)
    }
    /// Set the media URI to play on a renderer
    let setMediaUriChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setMediaUri\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMediaUriChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        let uriArg = args[1] as! String
        let metadataArg = args[2] as! MediaMetadata
        do {
          try api.setMediaUri(deviceUdn: deviceUdnArg, uri: uriArg, metadata: metadataArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMediaUriChannel.setMessageHandler(nil)
    }
    /// Start playback
    let playChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.play\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      playChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          try api.play(deviceUdn: deviceUdnArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      playChannel.setMessageHandler(nil)
    }
    /// Pause playback
    let pauseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.pause\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          try api.pause(deviceUdn: deviceUdnArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      pauseChannel.setMessageHandler(nil)
    }
    /// Stop playback
    let stopChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.stop\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          try api.stop(deviceUdn: deviceUdnArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      stopChannel.setMessageHandler(nil)
    }
    /// Seek to specific position (in seconds)
    let seekChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.seek\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      seekChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        let positionSecondsArg = args[1] as! Int64
        do {
          try api.seek(deviceUdn: deviceUdnArg, positionSeconds: positionSecondsArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      seekChannel.setMessageHandler(nil)
    }
    /// Skip to next track
    let nextChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.next\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      nextChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          try api.next(deviceUdn: deviceUdnArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      nextChannel.setMessageHandler(nil)
    }
    /// Skip to previous track
    let previousChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.previous\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      previousChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          try api.previous(deviceUdn: deviceUdnArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      previousChannel.setMessageHandler(nil)
    }
    /// Set volume (0-100)
    let setVolumeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setVolume\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setVolumeChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        let volumeArg = args[1] as! Int64
        do {
          try api.setVolume(deviceUdn: deviceUdnArg, volume: volumeArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setVolumeChannel.setMessageHandler(nil)
    }
    /// Get current volume info
    let getVolumeInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getVolumeInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getVolumeInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          let result = try api.getVolumeInfo(deviceUdn: deviceUdnArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getVolumeInfoChannel.setMessageHandler(nil)
    }
    /// Mute/unmute audio
    let setMuteChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.setMute\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setMuteChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        let mutedArg = args[1] as! Bool
        do {
          try api.setMute(deviceUdn: deviceUdnArg, muted: mutedArg)
          reply(wrapResult(nil))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      setMuteChannel.setMessageHandler(nil)
    }
    /// Get current playback information
    let getPlaybackInfoChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getPlaybackInfo\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlaybackInfoChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          let result = try api.getPlaybackInfo(deviceUdn: deviceUdnArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlaybackInfoChannel.setMessageHandler(nil)
    }
    /// Get current position info
    let getCurrentPositionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getCurrentPosition\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCurrentPositionChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          let result = try api.getCurrentPosition(deviceUdn: deviceUdnArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getCurrentPositionChannel.setMessageHandler(nil)
    }
    /// Get transport state
    let getTransportStateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getTransportState\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getTransportStateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let deviceUdnArg = args[0] as! String
        do {
          let result = try api.getTransportState(deviceUdn: deviceUdnArg)
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getTransportStateChannel.setMessageHandler(nil)
    }
    /// Get platform version
    let getPlatformVersionChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getPlatformVersion\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getPlatformVersionChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getPlatformVersion()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getPlatformVersionChannel.setMessageHandler(nil)
    }
    /// Check if UPnP is available on the platform
    let isUpnpAvailableChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.isUpnpAvailable\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      isUpnpAvailableChannel.setMessageHandler { _, reply in
        do {
          let result = try api.isUpnpAvailable()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      isUpnpAvailableChannel.setMessageHandler(nil)
    }
    /// Get network interface information
    let getNetworkInterfacesChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.media_cast_dlna.MediaCastDlnaApi.getNetworkInterfaces\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getNetworkInterfacesChannel.setMessageHandler { _, reply in
        do {
          let result = try api.getNetworkInterfaces()
          reply(wrapResult(result))
        } catch {
          reply(wrapError(error))
        }
      }
    } else {
      getNetworkInterfacesChannel.setMessageHandler(nil)
    }
  }
}
